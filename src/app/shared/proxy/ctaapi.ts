//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const URL_BASE_URL_API = new InjectionToken<string>('URL_BASE_URL_API');

@Injectable()
export class AccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    autenticar(body: UsuarioLoginRequest | undefined): Observable<SwaggerResponse<UsuarioLoginResponseApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Account/Autenticar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutenticar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutenticar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UsuarioLoginResponseApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UsuarioLoginResponseApiResponse>>;
        }));
    }

    protected processAutenticar(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioLoginResponseApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UsuarioLoginResponseApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioLoginResponseApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class AgenteDeCargaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param agenteId (optional) 
     * @return Success
     */
    obterAgenteDeCargaPorId(agenteId: number | undefined): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/ObterAgenteDeCargaPorId?";
        if (agenteId === null)
            throw new Error("The parameter 'agenteId' cannot be null.");
        else if (agenteId !== undefined)
            url_ += "agenteId=" + encodeURIComponent("" + agenteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterAgenteDeCargaPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterAgenteDeCargaPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>;
        }));
    }

    protected processObterAgenteDeCargaPorId(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AgenteDeCargaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarAgentesDeCarga(empresaId: number | undefined): Observable<SwaggerResponse<AgenteDeCargaResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/ListarAgentesDeCarga?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarAgentesDeCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarAgentesDeCarga(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgenteDeCargaResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgenteDeCargaResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarAgentesDeCarga(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AgenteDeCargaResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirAgenteDeCarga(body: AgenteDeCargaInsertRequest | undefined): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/InserirAgenteDeCarga";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirAgenteDeCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirAgenteDeCarga(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>;
        }));
    }

    protected processInserirAgenteDeCarga(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AgenteDeCargaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarAgenteDeCarga(body: AgenteDeCargaUpdateRequest | undefined): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/AtualizarAgenteDeCarga";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarAgenteDeCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarAgenteDeCarga(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>;
        }));
    }

    protected processAtualizarAgenteDeCarga(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AgenteDeCargaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param agenteId (optional) 
     * @return Success
     */
    excluirAgenteDeCarga(agenteId: number | undefined): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/ExcluirAgenteDeCarga?";
        if (agenteId === null)
            throw new Error("The parameter 'agenteId' cannot be null.");
        else if (agenteId !== undefined)
            url_ += "agenteId=" + encodeURIComponent("" + agenteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirAgenteDeCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirAgenteDeCarga(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>;
        }));
    }

    protected processExcluirAgenteDeCarga(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AgenteDeCargaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarAgentesDeCargaSimples(empresaId: number | undefined): Observable<SwaggerResponse<AgenteDeCargaListaSimplesResponseIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/ListarAgentesDeCargaSimples?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarAgentesDeCargaSimples(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarAgentesDeCargaSimples(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgenteDeCargaListaSimplesResponseIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgenteDeCargaListaSimplesResponseIEnumerableApiResponse>>;
        }));
    }

    protected processListarAgentesDeCargaSimples(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaListaSimplesResponseIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AgenteDeCargaListaSimplesResponseIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaListaSimplesResponseIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class CertificadoDigitalClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarCertificadosDigitais(empresaId: number | undefined): Observable<SwaggerResponse<CertificadoDigitalResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CertificadoDigital/ListarCertificadosDigitais?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarCertificadosDigitais(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarCertificadosDigitais(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<CertificadoDigitalResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<CertificadoDigitalResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarCertificadosDigitais(response: HttpResponseBase): Observable<SwaggerResponse<CertificadoDigitalResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CertificadoDigitalResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CertificadoDigitalResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class CiaAereaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param ciaId (optional) 
     * @return Success
     */
    obterCiaAereaPorId(ciaId: number | undefined): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/ObterCiaAereaPorId?";
        if (ciaId === null)
            throw new Error("The parameter 'ciaId' cannot be null.");
        else if (ciaId !== undefined)
            url_ += "ciaId=" + encodeURIComponent("" + ciaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterCiaAereaPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterCiaAereaPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>;
        }));
    }

    protected processObterCiaAereaPorId(response: HttpResponseBase): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CiaAereaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAereaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarCiasAereas(empresaId: number | undefined): Observable<SwaggerResponse<CiaAereaResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/ListarCiasAereas?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarCiasAereas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarCiasAereas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<CiaAereaResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<CiaAereaResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarCiasAereas(response: HttpResponseBase): Observable<SwaggerResponse<CiaAereaResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CiaAereaResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAereaResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirCiaAerea(body: CiaAereaInsertRequest | undefined): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/InserirCiaAerea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirCiaAerea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirCiaAerea(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>;
        }));
    }

    protected processInserirCiaAerea(response: HttpResponseBase): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CiaAereaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAereaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarCiaAerea(body: CiaAereaUpdateRequest | undefined): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/AtualizarCiaAerea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarCiaAerea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarCiaAerea(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>;
        }));
    }

    protected processAtualizarCiaAerea(response: HttpResponseBase): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CiaAereaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAereaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param ciaId (optional) 
     * @return Success
     */
    excluirCiaAerea(ciaId: number | undefined): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/ExcluirCiaAerea?";
        if (ciaId === null)
            throw new Error("The parameter 'ciaId' cannot be null.");
        else if (ciaId !== undefined)
            url_ += "ciaId=" + encodeURIComponent("" + ciaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirCiaAerea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirCiaAerea(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>;
        }));
    }

    protected processExcluirCiaAerea(response: HttpResponseBase): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CiaAereaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAereaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarCiasAereasSimples(empresaId: number | undefined): Observable<SwaggerResponse<CiaAreaListaSimplesResponseIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/ListarCiasAereasSimples?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarCiasAereasSimples(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarCiasAereasSimples(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<CiaAreaListaSimplesResponseIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<CiaAreaListaSimplesResponseIEnumerableApiResponse>>;
        }));
    }

    protected processListarCiasAereasSimples(response: HttpResponseBase): Observable<SwaggerResponse<CiaAreaListaSimplesResponseIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CiaAreaListaSimplesResponseIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAreaListaSimplesResponseIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class HouseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param houseId (optional) 
     * @return Success
     */
    obterHousePorId(houseId: number | undefined): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/ObterHousePorId?";
        if (houseId === null)
            throw new Error("The parameter 'houseId' cannot be null.");
        else if (houseId !== undefined)
            url_ += "houseId=" + encodeURIComponent("" + houseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterHousePorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterHousePorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
        }));
    }

    protected processObterHousePorId(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HouseResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarHouses(body: HouseListarRequest | undefined): Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/ListarHouses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarHouses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarHouses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarHouses(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HouseResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listhouseassociationupload(body: HouseListarRequest | undefined): Observable<SwaggerResponse<MasterHouseAssociationUploadResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/House/listhouseassociationupload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListhouseassociationupload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListhouseassociationupload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterHouseAssociationUploadResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterHouseAssociationUploadResponse[]>>;
        }));
    }

    protected processListhouseassociationupload(response: HttpResponseBase): Observable<SwaggerResponse<MasterHouseAssociationUploadResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterHouseAssociationUploadResponse[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterHouseAssociationUploadResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarHousesPorDataCriacao(body: MasterHousePorDataCriacaoRequest | undefined): Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/ListarHousesPorDataCriacao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarHousesPorDataCriacao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarHousesPorDataCriacao(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarHousesPorDataCriacao(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HouseResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirHouse(body: HouseInsertRequestDto | undefined): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/InserirHouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirHouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirHouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
        }));
    }

    protected processInserirHouse(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HouseResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarHouse(body: HouseUpdateRequestDto | undefined): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/AtualizarHouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarHouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarHouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
        }));
    }

    protected processAtualizarHouse(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HouseResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param houseId (optional) 
     * @return Success
     */
    atualizarReenviarHouse(houseId: number | undefined): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/AtualizarReenviarHouse?";
        if (houseId === null)
            throw new Error("The parameter 'houseId' cannot be null.");
        else if (houseId !== undefined)
            url_ += "houseId=" + encodeURIComponent("" + houseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarReenviarHouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarReenviarHouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
        }));
    }

    protected processAtualizarReenviarHouse(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HouseResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param houseId (optional) 
     * @return Success
     */
    atualizarReenviarAssociacaoHouse(houseId: number | undefined): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/AtualizarReenviarAssociacaoHouse?";
        if (houseId === null)
            throw new Error("The parameter 'houseId' cannot be null.");
        else if (houseId !== undefined)
            url_ += "houseId=" + encodeURIComponent("" + houseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarReenviarAssociacaoHouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarReenviarAssociacaoHouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
        }));
    }

    protected processAtualizarReenviarAssociacaoHouse(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HouseResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param houseId (optional) 
     * @return Success
     */
    excluirHouse(houseId: number | undefined): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/ExcluirHouse?";
        if (houseId === null)
            throw new Error("The parameter 'houseId' cannot be null.");
        else if (houseId !== undefined)
            url_ += "houseId=" + encodeURIComponent("" + houseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirHouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirHouse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<HouseResponseDtoApiResponse>>;
        }));
    }

    protected processExcluirHouse(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HouseResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class MasterClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param masterId (optional) 
     * @return Success
     */
    obterMasterPorId(masterId: number | undefined): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ObterMasterPorId?";
        if (masterId === null)
            throw new Error("The parameter 'masterId' cannot be null.");
        else if (masterId !== undefined)
            url_ += "masterId=" + encodeURIComponent("" + masterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterMasterPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterMasterPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterResponseDtoApiResponse>>;
        }));
    }

    protected processObterMasterPorId(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarMasters(body: MasterListarRequest | undefined): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ListarMasters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarMasters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarMasters(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarMasters(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarMastersPorDataCriacao(body: MasterHousePorDataCriacaoRequest | undefined): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ListarMastersPorDataCriacao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarMastersPorDataCriacao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarMastersPorDataCriacao(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarMastersPorDataCriacao(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    listarMastersVoo(vooId: number | undefined): Observable<SwaggerResponse<MasterVooResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ListarMastersVoo?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarMastersVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarMastersVoo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterVooResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterVooResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarMastersVoo(response: HttpResponseBase): Observable<SwaggerResponse<MasterVooResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterVooResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterVooResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    listarMastersListaPorVooId(vooId: number | undefined): Observable<SwaggerResponse<MasterListaResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ListarMastersListaPorVooId?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarMastersListaPorVooId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarMastersListaPorVooId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterListaResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterListaResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarMastersListaPorVooId(response: HttpResponseBase): Observable<SwaggerResponse<MasterListaResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterListaResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterListaResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirMaster(body: MasterInsertRequestDto | undefined): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/InserirMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterResponseDtoApiResponse>>;
        }));
    }

    protected processInserirMaster(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarMaster(body: MasterUpdateRequestDto | undefined): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/AtualizarMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterResponseDtoApiResponse>>;
        }));
    }

    protected processAtualizarMaster(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarReeviarMaster(body: AtualizarMasterReenviarRequest | undefined): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/AtualizarReeviarMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarReeviarMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarReeviarMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processAtualizarReeviarMaster(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    excluirMaster(body: ExcluirMastersByIdRequest | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ExcluirMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<StringApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<StringApiResponse>>;
        }));
    }

    protected processExcluirMaster(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @return Success
     */
    listarArquivosImportacao(): Observable<SwaggerResponse<MasterFileResponseDtoListApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ListarArquivosImportacao";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarArquivosImportacao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarArquivosImportacao(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterFileResponseDtoListApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterFileResponseDtoListApiResponse>>;
        }));
    }

    protected processListarArquivosImportacao(response: HttpResponseBase): Observable<SwaggerResponse<MasterFileResponseDtoListApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterFileResponseDtoListApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterFileResponseDtoListApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param vooId (optional) 
     * @param fileImportId (optional) 
     * @param file (optional) 
     * @return Success
     */
    uploadImportFile(vooId: number | undefined, fileImportId: number | undefined, file: FileParameter | undefined): Observable<SwaggerResponse<MasterResponseDtoListApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/UploadImportFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (vooId === null || vooId === undefined)
            throw new Error("The parameter 'vooId' cannot be null.");
        else
            content_.append("VooId", vooId.toString());
        if (fileImportId === null || fileImportId === undefined)
            throw new Error("The parameter 'fileImportId' cannot be null.");
        else
            content_.append("FileImportId", fileImportId.toString());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImportFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImportFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterResponseDtoListApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterResponseDtoListApiResponse>>;
        }));
    }

    protected processUploadImportFile(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoListApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterResponseDtoListApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoListApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class NaturezaCargaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param naturezaCargaId (optional) 
     * @return Success
     */
    obterNaturezaCargaPorId(naturezaCargaId: number | undefined): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/NaturezaCarga/ObterNaturezaCargaPorId?";
        if (naturezaCargaId === null)
            throw new Error("The parameter 'naturezaCargaId' cannot be null.");
        else if (naturezaCargaId !== undefined)
            url_ += "naturezaCargaId=" + encodeURIComponent("" + naturezaCargaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterNaturezaCargaPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterNaturezaCargaPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>;
        }));
    }

    protected processObterNaturezaCargaPorId(response: HttpResponseBase): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NaturezaCargaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarNaturezaCarga(empresaId: number | undefined): Observable<SwaggerResponse<NaturezaCargaResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/NaturezaCarga/ListarNaturezaCarga?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarNaturezaCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarNaturezaCarga(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NaturezaCargaResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NaturezaCargaResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarNaturezaCarga(response: HttpResponseBase): Observable<SwaggerResponse<NaturezaCargaResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NaturezaCargaResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NaturezaCargaResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirNaturezaCarga(body: NaturezaCargaInsertRequestDto | undefined): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/NaturezaCarga/InserirNaturezaCarga";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirNaturezaCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirNaturezaCarga(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>;
        }));
    }

    protected processInserirNaturezaCarga(response: HttpResponseBase): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NaturezaCargaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarNaturezaCarga(body: NaturezaCargaUpdateRequestDto | undefined): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/NaturezaCarga/AtualizarNaturezaCarga";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarNaturezaCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarNaturezaCarga(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>;
        }));
    }

    protected processAtualizarNaturezaCarga(response: HttpResponseBase): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NaturezaCargaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param naturezaCargaId (optional) 
     * @return Success
     */
    excluirNaturezaCarga(naturezaCargaId: number | undefined): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/NaturezaCarga/ExcluirNaturezaCarga?";
        if (naturezaCargaId === null)
            throw new Error("The parameter 'naturezaCargaId' cannot be null.");
        else if (naturezaCargaId !== undefined)
            url_ += "naturezaCargaId=" + encodeURIComponent("" + naturezaCargaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirNaturezaCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirNaturezaCarga(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>;
        }));
    }

    protected processExcluirNaturezaCarga(response: HttpResponseBase): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NaturezaCargaResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class NcmClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param q (optional) 
     * @return Success
     */
    search(q: string | undefined): Observable<SwaggerResponse<NCM[]>> {
        let url_ = this.baseUrl + "/api/v1/Ncm/search?";
        if (q === null)
            throw new Error("The parameter 'q' cannot be null.");
        else if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NCM[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NCM[]>>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SwaggerResponse<NCM[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NCM[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NCM[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchcodes(body: string[] | undefined): Observable<SwaggerResponse<NCM[]>> {
        let url_ = this.baseUrl + "/api/v1/Ncm/searchcodes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchcodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchcodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<NCM[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<NCM[]>>;
        }));
    }

    protected processSearchcodes(response: HttpResponseBase): Observable<SwaggerResponse<NCM[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NCM[];
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NCM[]>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class PortoIATAClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param portoIATAId (optional) 
     * @return Success
     */
    obterPortoIATAPorId(portoIATAId: number | undefined): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/PortoIATA/ObterPortoIATAPorId?";
        if (portoIATAId === null)
            throw new Error("The parameter 'portoIATAId' cannot be null.");
        else if (portoIATAId !== undefined)
            url_ += "portoIATAId=" + encodeURIComponent("" + portoIATAId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterPortoIATAPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterPortoIATAPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>;
        }));
    }

    protected processObterPortoIATAPorId(response: HttpResponseBase): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PortoIATAResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PortoIATAResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarPortosIATA(empresaId: number | undefined): Observable<SwaggerResponse<PortoIATAResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/PortoIATA/ListarPortosIATA?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarPortosIATA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarPortosIATA(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PortoIATAResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PortoIATAResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarPortosIATA(response: HttpResponseBase): Observable<SwaggerResponse<PortoIATAResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PortoIATAResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PortoIATAResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirPortoIATA(body: PortoIATAInsertRequestDto | undefined): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/PortoIATA/InserirPortoIATA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirPortoIATA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirPortoIATA(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>;
        }));
    }

    protected processInserirPortoIATA(response: HttpResponseBase): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PortoIATAResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PortoIATAResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarPortoIATA(body: PortoIATAUpdateRequestDto | undefined): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/PortoIATA/AtualizarPortoIATA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarPortoIATA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarPortoIATA(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>;
        }));
    }

    protected processAtualizarPortoIATA(response: HttpResponseBase): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PortoIATAResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PortoIATAResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param portoIATAId (optional) 
     * @return Success
     */
    excluirPortoIATA(portoIATAId: number | undefined): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/PortoIATA/ExcluirPortoIATA?";
        if (portoIATAId === null)
            throw new Error("The parameter 'portoIATAId' cannot be null.");
        else if (portoIATAId !== undefined)
            url_ += "portoIATAId=" + encodeURIComponent("" + portoIATAId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirPortoIATA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirPortoIATA(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>;
        }));
    }

    protected processExcluirPortoIATA(response: HttpResponseBase): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PortoIATAResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PortoIATAResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class ReceitaFederalClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submeterVooCompleto(body: VooUploadInput | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/ReceitaFederal/SubmeterVooCompleto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmeterVooCompleto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmeterVooCompleto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<StringApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<StringApiResponse>>;
        }));
    }

    protected processSubmeterVooCompleto(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submeterMasterVooCompleto(body: VooUploadInput | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/ReceitaFederal/SubmeterMasterVooCompleto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmeterMasterVooCompleto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmeterMasterVooCompleto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<StringApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<StringApiResponse>>;
        }));
    }

    protected processSubmeterMasterVooCompleto(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verificarProtocoloVoo(body: VooUploadInput | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/ReceitaFederal/VerificarProtocoloVoo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerificarProtocoloVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerificarProtocoloVoo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<StringApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<StringApiResponse>>;
        }));
    }

    protected processVerificarProtocoloVoo(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submeterMasterExclusion(body: MasterExclusaoRFBInput | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/ReceitaFederal/SubmeterMasterExclusion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmeterMasterExclusion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmeterMasterExclusion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<StringApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<StringApiResponse>>;
        }));
    }

    protected processSubmeterMasterExclusion(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submeterHouseAgenteDeCarga(body: SubmeterRFBHouseRequest | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/ReceitaFederal/SubmeterHouseAgenteDeCarga";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmeterHouseAgenteDeCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmeterHouseAgenteDeCarga(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<StringApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<StringApiResponse>>;
        }));
    }

    protected processSubmeterHouseAgenteDeCarga(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submeterAssociacaoHouseMaster(body: SubmeterRFBMasterHouseRequest | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/ReceitaFederal/SubmeterAssociacaoHouseMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmeterAssociacaoHouseMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmeterAssociacaoHouseMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<StringApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<StringApiResponse>>;
        }));
    }

    protected processSubmeterAssociacaoHouseMaster(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class UldClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param uldId (optional) 
     * @return Success
     */
    pegarUldMasterPorId(uldId: number | undefined): Observable<SwaggerResponse<UldMasterResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/PegarUldMasterPorId?";
        if (uldId === null)
            throw new Error("The parameter 'uldId' cannot be null.");
        else if (uldId !== undefined)
            url_ += "uldId=" + encodeURIComponent("" + uldId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPegarUldMasterPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPegarUldMasterPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UldMasterResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UldMasterResponseDtoApiResponse>>;
        }));
    }

    protected processPegarUldMasterPorId(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UldMasterResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param masterId (optional) 
     * @return Success
     */
    listarUldMasterPorMasterId(masterId: number | undefined): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ListarUldMasterPorMasterId?";
        if (masterId === null)
            throw new Error("The parameter 'masterId' cannot be null.");
        else if (masterId !== undefined)
            url_ += "masterId=" + encodeURIComponent("" + masterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarUldMasterPorMasterId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarUldMasterPorMasterId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>;
        }));
    }

    protected processListarUldMasterPorMasterId(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UldMasterResponseDtoListApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterResponseDtoListApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    listarUldMasterPorVooId(vooId: number | undefined): Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ListarUldMasterPorVooId?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarUldMasterPorVooId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarUldMasterPorVooId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>>;
        }));
    }

    protected processListarUldMasterPorVooId(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UldMasterNumeroQueryIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param trechoId (optional) 
     * @return Success
     */
    listarUldMasterPorTrechoId(trechoId: number | undefined): Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ListarUldMasterPorTrechoId?";
        if (trechoId === null)
            throw new Error("The parameter 'trechoId' cannot be null.");
        else if (trechoId !== undefined)
            url_ += "trechoId=" + encodeURIComponent("" + trechoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarUldMasterPorTrechoId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarUldMasterPorTrechoId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>>;
        }));
    }

    protected processListarUldMasterPorTrechoId(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UldMasterNumeroQueryIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarUldMasterPorLinha(body: ListaUldMasterRequest | undefined): Observable<SwaggerResponse<UldMasterResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ListarUldMasterPorLinha";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarUldMasterPorLinha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarUldMasterPorLinha(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UldMasterResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UldMasterResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarUldMasterPorLinha(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UldMasterResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarMasterUldSumario(body: ListaUldMasterRequest | undefined): Observable<SwaggerResponse<MasterNumeroUldSumarioIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ListarMasterUldSumario";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarMasterUldSumario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarMasterUldSumario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<MasterNumeroUldSumarioIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<MasterNumeroUldSumarioIEnumerableApiResponse>>;
        }));
    }

    protected processListarMasterUldSumario(response: HttpResponseBase): Observable<SwaggerResponse<MasterNumeroUldSumarioIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MasterNumeroUldSumarioIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterNumeroUldSumarioIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirUldMaster(body: UldMasterInsertRequest[] | undefined): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/InserirUldMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirUldMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirUldMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>;
        }));
    }

    protected processInserirUldMaster(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UldMasterResponseDtoListApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterResponseDtoListApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarUldMaster(body: UldMasterUpdateRequest[] | undefined): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/AtualizarUldMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarUldMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarUldMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>;
        }));
    }

    protected processAtualizarUldMaster(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UldMasterResponseDtoListApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterResponseDtoListApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    excluirUldMaster(body: UldMasterDeleteByIdInput | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ExcluirUldMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirUldMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirUldMaster(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<StringApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<StringApiResponse>>;
        }));
    }

    protected processExcluirUldMaster(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    excluirUld(body: UldMasterDeleteByTagInput | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ExcluirUld";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirUld(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirUld(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<StringApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<StringApiResponse>>;
        }));
    }

    protected processExcluirUld(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class UploadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @param usuarioId (optional) 
     * @param senha (optional) 
     * @param empresaId (optional) 
     * @param certificadoDestino (optional) 
     * @param file (optional) 
     * @return Success
     */
    uploadCertificadoDigital(id: number | undefined, usuarioId: number | undefined, senha: string | undefined, empresaId: number | undefined, certificadoDestino: FileDestinationMap | undefined, file: FileParameter | undefined): Observable<SwaggerResponse<UploadCertificadoResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Upload/UploadCertificadoDigital";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (usuarioId === null || usuarioId === undefined)
            throw new Error("The parameter 'usuarioId' cannot be null.");
        else
            content_.append("UsuarioId", usuarioId.toString());
        if (senha === null || senha === undefined)
            throw new Error("The parameter 'senha' cannot be null.");
        else
            content_.append("Senha", senha.toString());
        if (empresaId === null || empresaId === undefined)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else
            content_.append("EmpresaId", empresaId.toString());
        if (certificadoDestino === null || certificadoDestino === undefined)
            throw new Error("The parameter 'certificadoDestino' cannot be null.");
        else
            content_.append("CertificadoDestino", certificadoDestino.toString());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadCertificadoDigital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadCertificadoDigital(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UploadCertificadoResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UploadCertificadoResponseDtoApiResponse>>;
        }));
    }

    protected processUploadCertificadoDigital(response: HttpResponseBase): Observable<SwaggerResponse<UploadCertificadoResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UploadCertificadoResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UploadCertificadoResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class UsuarioClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param usuarioId (optional) 
     * @return Success
     */
    obterUsuarioPorId(usuarioId: number | undefined): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/ObterUsuarioPorId?";
        if (usuarioId === null)
            throw new Error("The parameter 'usuarioId' cannot be null.");
        else if (usuarioId !== undefined)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterUsuarioPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterUsuarioPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>;
        }));
    }

    protected processObterUsuarioPorId(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UsuarioResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarUsuarios(empresaId: number | undefined): Observable<SwaggerResponse<UsuarioResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/ListarUsuarios?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarUsuarios(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarUsuarios(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UsuarioResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UsuarioResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarUsuarios(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UsuarioResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirUsuario(body: UsuarioInsertRequest | undefined): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/InserirUsuario";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>;
        }));
    }

    protected processInserirUsuario(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UsuarioResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarUsuario(body: UsuarioUpdateRequest | undefined): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/AtualizarUsuario";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>;
        }));
    }

    protected processAtualizarUsuario(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UsuarioResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetarUsuario(body: UsuarioUpdateRequest | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/ResetarUsuario";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetarUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetarUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<StringApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<StringApiResponse>>;
        }));
    }

    protected processResetarUsuario(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param usuarioId (optional) 
     * @return Success
     */
    excluirUsuario(usuarioId: number | undefined): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/ExcluirUsuario?";
        if (usuarioId === null)
            throw new Error("The parameter 'usuarioId' cannot be null.");
        else if (usuarioId !== undefined)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>;
        }));
    }

    protected processExcluirUsuario(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UsuarioResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

@Injectable()
export class VooClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    obterVooPorId(vooId: number | undefined): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/ObterVooPorId?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterVooPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterVooPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<VooResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<VooResponseDtoApiResponse>>;
        }));
    }

    protected processObterVooPorId(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VooResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    obterVooUploadPorId(vooId: number | undefined): Observable<SwaggerResponse<VooUploadResponseApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/ObterVooUploadPorId?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterVooUploadPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterVooUploadPorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<VooUploadResponseApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<VooUploadResponseApiResponse>>;
        }));
    }

    protected processObterVooUploadPorId(response: HttpResponseBase): Observable<SwaggerResponse<VooUploadResponseApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VooUploadResponseApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooUploadResponseApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarVoos(body: VooListarInputDto | undefined): Observable<SwaggerResponse<VooResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/ListarVoos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarVoos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarVoos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<VooResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<VooResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarVoos(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VooResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarVoosLista(body: VooListarInputDto | undefined): Observable<SwaggerResponse<VooListaResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/ListarVoosLista";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarVoosLista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarVoosLista(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<VooListaResponseDtoIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<VooListaResponseDtoIEnumerableApiResponse>>;
        }));
    }

    protected processListarVoosLista(response: HttpResponseBase): Observable<SwaggerResponse<VooListaResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VooListaResponseDtoIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooListaResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirVoo(body: VooInsertRequestDto | undefined): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/InserirVoo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirVoo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<VooResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<VooResponseDtoApiResponse>>;
        }));
    }

    protected processInserirVoo(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VooResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarVoo(body: VooUpdateRequestDto | undefined): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/AtualizarVoo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarVoo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<VooResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<VooResponseDtoApiResponse>>;
        }));
    }

    protected processAtualizarVoo(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VooResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    atualizarReenviarVoo(vooId: number | undefined): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/AtualizarReenviarVoo?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarReenviarVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarReenviarVoo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<VooResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<VooResponseDtoApiResponse>>;
        }));
    }

    protected processAtualizarReenviarVoo(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VooResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    excluirVoo(vooId: number | undefined): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/ExcluirVoo?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirVoo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<VooResponseDtoApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<VooResponseDtoApiResponse>>;
        }));
    }

    protected processExcluirVoo(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VooResponseDtoApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    listarVooTrechos(vooId: number | undefined): Observable<SwaggerResponse<VooTrechoResponseIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/ListarVooTrechos?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarVooTrechos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarVooTrechos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<VooTrechoResponseIEnumerableApiResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<VooTrechoResponseIEnumerableApiResponse>>;
        }));
    }

    protected processListarVooTrechos(response: HttpResponseBase): Observable<SwaggerResponse<VooTrechoResponseIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VooTrechoResponseIEnumerableApiResponse;
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooTrechoResponseIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, null as any));
    }
}

export interface AgenteDeCargaInsertRequest {
    EmpresaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    UsuarioId?: number;
    Numero?: string | undefined;
}

export interface AgenteDeCargaListaSimplesResponse {
    AgenteDeCargaId?: number;
    Nome?: string | undefined;
    Numero?: string | undefined;
}

export interface AgenteDeCargaListaSimplesResponseIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: AgenteDeCargaListaSimplesResponse[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface AgenteDeCargaResponseDto {
    AgenteDeCargaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    Numero?: string | undefined;
    ArquivoCertificado?: string | undefined;
    DataExpiracaoCertificado?: Date | undefined;
}

export interface AgenteDeCargaResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: AgenteDeCargaResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface AgenteDeCargaResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: AgenteDeCargaResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface AgenteDeCargaUpdateRequest {
    AgenteDeCargaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    UsuarioId?: number;
    Numero?: string | undefined;
}

export interface AtualizarMasterReenviarRequest {
    MasterIds?: number[] | undefined;
}

export interface CertificadoDigitalResponseDto {
    UsuarioCriacaoId?: number;
    UsuarioCriacao?: string | undefined;
    DataCriacao?: Date;
    UsuarioModificadorId?: number | undefined;
    UsuarioModificacao?: string | undefined;
    DataModificacao?: Date | undefined;
    Id?: number;
    Arquivo?: string | undefined;
    DataVencimento?: Date;
    NomeDono?: string | undefined;
    SerialNumber?: string | undefined;
}

export interface CertificadoDigitalResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: CertificadoDigitalResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface CiaAereaInsertRequest {
    EmpresaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    UsuarioId?: number;
    Numero?: string | undefined;
}

export interface CiaAereaResponseDto {
    CiaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    Numero?: string | undefined;
    ArquivoCertificado?: string | undefined;
    DataExpiracaoCertificado?: Date | undefined;
}

export interface CiaAereaResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: CiaAereaResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface CiaAereaResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: CiaAereaResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface CiaAereaUpdateRequest {
    CiaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    UsuarioId?: number;
    Numero?: string | undefined;
}

export interface CiaAreaListaSimplesResponse {
    CiaId?: number;
    Nome?: string | undefined;
}

export interface CiaAreaListaSimplesResponseIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: CiaAreaListaSimplesResponse[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface ExcluirMastersByIdRequest {
    MasterIds?: number[] | undefined;
}

export enum FileDestinationMap {
    _0 = 0,
    _1 = 1,
}

export interface HouseInsertRequestDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalVolumes?: number;
    Volume?: number | undefined;
    VolumeUN?: string | undefined;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: string | undefined;
    RUC?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigem?: string | undefined;
    AeroportoDestino?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    MasterNumeroXML?: string | undefined;
    NCMLista?: string[] | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    AgenteDeCargaNumero?: string | undefined;
    DataProcessamento?: Date;
}

export interface HouseListarRequest {
    DataProcessamento?: Date | undefined;
    AgenteDeCargaId?: number | undefined;
    DataCriacaoInicialUnica?: Date | undefined;
    DataCriacaoFinal?: Date | undefined;
    NumeroMaster?: string | undefined;
    Numero?: string | undefined;
    NomeLike?: string | undefined;
    StatusReceita?: number | undefined;
    DataEnvioReceita?: Date | undefined;
}

export interface HouseResponseDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalVolumes?: number;
    Volume?: number | undefined;
    VolumeUN?: string | undefined;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: string | undefined;
    RUC?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigem?: string | undefined;
    AeroportoDestino?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    MasterNumeroXML?: string | undefined;
    NCMLista?: string[] | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    AgenteDeCargaNumero?: string | undefined;
    HouseId?: number;
    StatusId?: number;
    SituacaoRFB?: number;
    ProtocoloRFB?: string | undefined;
    DescricaoErroRFB?: string | undefined;
    DataProcessamento?: Date;
    Reenviar?: boolean;
    ProtocoloAssociacaoRFB?: string | undefined;
    CodigoErroAssociacaoRFB?: string | undefined;
    DescricaoErroAssociacaoRFB?: string | undefined;
    SituacaoAssociacaoRFBId?: number;
    DataProtocoloAssociacaoRFB?: Date | undefined;
    DataChecagemAssociacaoRFB?: Date | undefined;
    ReenviarAssociacao?: boolean;
}

export interface HouseResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: HouseResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface HouseResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: HouseResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface HouseUpdateRequestDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalVolumes?: number;
    Volume?: number | undefined;
    VolumeUN?: string | undefined;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: string | undefined;
    RUC?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigem?: string | undefined;
    AeroportoDestino?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    MasterNumeroXML?: string | undefined;
    NCMLista?: string[] | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    AgenteDeCargaNumero?: string | undefined;
    HouseId?: number;
}

export interface ListaUldMasterRequest {
    vooId?: number;
    uldLinha?: string | undefined;
}

export interface MasterErroDto {
    Erro?: string | undefined;
}

export interface MasterExclusaoRFBInput {
    UsuarioId?: number;
    MasterId?: number;
}

export interface MasterFileResponseDto {
    FileImportId?: number;
    Description?: string | undefined;
}

export interface MasterFileResponseDtoListApiResponse {
    Sucesso?: boolean;
    Dados?: MasterFileResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface MasterHouseAssociationHouseItemResponse {
    Number?: string | undefined;
    OriginLocation?: string | undefined;
    DestinationLocation?: string | undefined;
    TotalWeight?: number;
    TotalWeightUnit?: string | undefined;
    PackageQuantity?: number;
    TotalPieceQuantity?: number;
    DocumentId?: string | undefined;
    AssociationProtocol?: string | undefined;
    AssociationErrorCode?: string | undefined;
    AssociationErrorDescription?: string | undefined;
    AssociationStatusId?: number;
    AssociationDate?: Date | undefined;
    AssociationCheckDate?: Date | undefined;
    ResendAssociation?: boolean;
    ProcessDate?: Date | undefined;
}

export interface MasterHouseAssociationSummaryUploadResponse {
    OriginLocation?: string | undefined;
    DestinationLocation?: string | undefined;
    TotalWeight?: number;
    TotalWeightUnit?: string | undefined;
    ConsignmentItemQuantity?: number;
    PackageQuantity?: number;
    TotalPieceQuantity?: number;
    IssueDate?: Date;
    DocumentId?: string | undefined;
}

export interface MasterHouseAssociationUploadResponse {
    Number?: string | undefined;
    Summary?: MasterHouseAssociationSummaryUploadResponse;
    Houses?: MasterHouseAssociationHouseItemResponse[] | undefined;
}

export interface MasterHousePorDataCriacaoRequest {
    DataCriacao?: Date;
}

export interface MasterInsertRequestDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalPecas?: number;
    ValorFOB?: number;
    ValorFOBUN?: string | undefined;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    IndicadorNaoDesunitizacao?: boolean;
    IndicadorAwbNaoIata?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: string | undefined;
    RUC?: string | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    RemetenteSubdivisao?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigemCodigo?: string | undefined;
    AeroportoDestinoCodigo?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    NumeroVooXML?: string | undefined;
    NCMLista?: string[] | undefined;
    ConsolidadoDireto?: string | undefined;
    TotalParcial?: string | undefined;
    NaturezaCarga?: string | undefined;
    Volume?: number | undefined;
    VolumeUN?: string | undefined;
    AssinaturaTransportadorNome?: string | undefined;
    AssinaturaTransportadorLocal?: string | undefined;
    AssinaturaTransportadorData?: Date | undefined;
    VooId?: number;
    DataVoo?: Date;
}

export interface MasterListaResponseDto {
    MasterId?: number;
    Numero?: string | undefined;
}

export interface MasterListaResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: MasterListaResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface MasterListarRequest {
    CiaAereaId?: number | undefined;
    VooId?: number | undefined;
    DataCriacaoInicialUnica?: Date | undefined;
    DataCriacaoFinal?: Date | undefined;
    Numero?: string | undefined;
    NomeLike?: string | undefined;
    StatusReceita?: RFStatusEnvioType;
    DataEnvioReceita?: Date | undefined;
}

export interface MasterNumeroUldSumario {
    MasterNumero?: string | undefined;
    MasterPecas?: number | undefined;
    MasterPeso?: number | undefined;
    MasterPesoUnidade?: string | undefined;
    Ulds?: MasterNumeroUldSumarioChildren[] | undefined;
}

export interface MasterNumeroUldSumarioChildren {
    UldNumero?: string | undefined;
    QuantidadePecas?: number;
    Peso?: number;
    PesoUnidade?: string | undefined;
    TotalParcial?: string | undefined;
    MesmoVoo?: boolean;
    VooNumero?: string | undefined;
    DataHoraChegadaEstimada?: Date | undefined;
    DataHoraChegadaReal?: Date | undefined;
}

export interface MasterNumeroUldSumarioIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: MasterNumeroUldSumario[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface MasterResponseDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalPecas?: number;
    ValorFOB?: number;
    ValorFOBUN?: string | undefined;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    IndicadorNaoDesunitizacao?: boolean;
    IndicadorAwbNaoIata?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: string | undefined;
    RUC?: string | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    RemetenteSubdivisao?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigemCodigo?: string | undefined;
    AeroportoDestinoCodigo?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    NumeroVooXML?: string | undefined;
    NCMLista?: string[] | undefined;
    ConsolidadoDireto?: string | undefined;
    TotalParcial?: string | undefined;
    NaturezaCarga?: string | undefined;
    Volume?: number | undefined;
    VolumeUN?: string | undefined;
    AssinaturaTransportadorNome?: string | undefined;
    AssinaturaTransportadorLocal?: string | undefined;
    AssinaturaTransportadorData?: Date | undefined;
    MasterId?: number;
    StatusId?: number;
    SituacaoRFB?: number;
    ProtocoloRFB?: string | undefined;
    CodigoErroRFB?: string | undefined;
    DescricoErroRFB?: string | undefined;
    DataProtocoloRFB?: Date | undefined;
    Erros?: MasterErroDto[] | undefined;
    Reenviar?: boolean;
    StatusVoo?: RecordStatus;
    UsuarioCriacao?: string | undefined;
    DataCriacao?: Date;
}

export interface MasterResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: MasterResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface MasterResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: MasterResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface MasterResponseDtoListApiResponse {
    Sucesso?: boolean;
    Dados?: MasterResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface MasterUpdateRequestDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalPecas?: number;
    ValorFOB?: number;
    ValorFOBUN?: string | undefined;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    IndicadorNaoDesunitizacao?: boolean;
    IndicadorAwbNaoIata?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: string | undefined;
    RUC?: string | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    RemetenteSubdivisao?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigemCodigo?: string | undefined;
    AeroportoDestinoCodigo?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    NumeroVooXML?: string | undefined;
    NCMLista?: string[] | undefined;
    ConsolidadoDireto?: string | undefined;
    TotalParcial?: string | undefined;
    NaturezaCarga?: string | undefined;
    Volume?: number | undefined;
    VolumeUN?: string | undefined;
    AssinaturaTransportadorNome?: string | undefined;
    AssinaturaTransportadorLocal?: string | undefined;
    AssinaturaTransportadorData?: Date | undefined;
    MasterId?: number;
    DataVoo?: Date;
}

export interface MasterVooResponseDto {
    Numero?: string | undefined;
    CodigoTipo?: string | undefined;
    Peso?: number;
    PesoUnidade?: string | undefined;
    TotalVolumes?: number;
    Descricao?: string | undefined;
    PortoOrigemId?: number;
    PortoDestinoId?: number;
}

export interface MasterVooResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: MasterVooResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface NCM {
    Id: number;
    Codigo: string;
    Descricao: string;
    DescricaoConcatenada: string;
    Seleciona?: boolean;
    CodigoNumero?: string | undefined;
}

export interface NaturezaCargaInsertRequestDto {
    Codigo?: string | undefined;
    Descricao?: string | undefined;
    UsuarioInsercaoId?: number;
    EmpresaId?: number;
}

export interface NaturezaCargaResponseDto {
    NaturezaCargaId?: number;
    Codigo?: string | undefined;
    Descricao?: string | undefined;
}

export interface NaturezaCargaResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: NaturezaCargaResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface NaturezaCargaResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: NaturezaCargaResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface NaturezaCargaUpdateRequestDto {
    NaturezaCargaId?: number;
    Descricao?: string | undefined;
    UsuarioModificadorId?: number;
}

export interface Notificacao {
    Codigo?: string | undefined;
    Mensagem?: string | undefined;
}

export interface PortoIATAInsertRequestDto {
    Codigo?: string | undefined;
    Nome?: string | undefined;
    UsuarioInsercaoId?: number;
    EmpresaId?: number;
}

export interface PortoIATAResponseDto {
    PortoId?: number;
    Codigo?: string | undefined;
    Nome?: string | undefined;
}

export interface PortoIATAResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: PortoIATAResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface PortoIATAResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: PortoIATAResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface PortoIATAUpdateRequestDto {
    PortoIATAId?: number;
    Nome?: string | undefined;
    UsuarioModificadorId?: number;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export enum RFStatusEnvioType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum RecordStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export interface StringApiResponse {
    Sucesso?: boolean;
    Dados?: string | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface SubmeterRFBHouseRequest {
    DataProcessamento?: Date;
    AgenteDeCargaId?: number;
}

export interface SubmeterRFBMasterHouseItemRequest {
    MasterNumber?: string | undefined;
    OriginLocation?: string | undefined;
    DestinationLocation?: string | undefined;
    TotalWeight?: number;
    TotalWeightUnit?: string | undefined;
    PackageQuantity?: number;
    TotalPiece?: number;
}

export interface SubmeterRFBMasterHouseRequest {
    FreightFowarderId?: number;
    Masters?: SubmeterRFBMasterHouseItemRequest[] | undefined;
}

export interface UldMasterDeleteByIdInput {
    TrechoId?: number;
    ListaIds?: number[] | undefined;
}

export interface UldMasterDeleteByTagInput {
    VooId?: number;
    ULDId?: string | undefined;
    ULDCaracteristicaCodigo?: string | undefined;
    ULDIdPrimario?: string | undefined;
}

export interface UldMasterInsertRequest {
    MasterNumero?: string | undefined;
    UldId?: string | undefined;
    UldCaracteristicaCodigo?: string | undefined;
    UldIdPrimario?: string | undefined;
    QuantidadePecas?: number;
    Peso?: number;
    TrechoId?: number;
}

export interface UldMasterNumeroQuery {
    ULDCaracteristicaCodigo?: string | undefined;
    ULDId?: string | undefined;
    ULDIdPrimario?: string | undefined;
    readonly ULDLinha?: string | undefined;
    ULDs?: UldMasterNumeroQueryChildren[] | undefined;
}

export interface UldMasterNumeroQueryChildren {
    MasterId?: number;
    MasterNumero?: string | undefined;
    UldId?: string | undefined;
    UldCaracteristicaCodigo?: string | undefined;
    UldIdPrimario?: string | undefined;
    QuantidadePecas?: number | undefined;
    Peso?: number | undefined;
    PesoUnidade?: string | undefined;
    Id?: number;
    UsuarioCriacao?: string | undefined;
    DataCricao?: Date;
    TotalParcial?: string | undefined;
}

export interface UldMasterNumeroQueryIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: UldMasterNumeroQuery[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UldMasterResponseDto {
    MasterNumero?: string | undefined;
    UldId?: string | undefined;
    UldCaracteristicaCodigo?: string | undefined;
    UldIdPrimario?: string | undefined;
    QuantidadePecas?: number;
    Peso?: number;
    Id?: number;
    MasterId?: number;
    UsuarioCriacao?: string | undefined;
    DataCricao?: Date | undefined;
}

export interface UldMasterResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: UldMasterResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UldMasterResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: UldMasterResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UldMasterResponseDtoListApiResponse {
    Sucesso?: boolean;
    Dados?: UldMasterResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UldMasterUpdateRequest {
    MasterNumero?: string | undefined;
    UldId?: string | undefined;
    UldCaracteristicaCodigo?: string | undefined;
    UldIdPrimario?: string | undefined;
    QuantidadePecas?: number;
    Peso?: number;
    Id?: number;
    TrechoId?: number;
}

export interface UploadCertificadoResponseDto {
    NomeArquivo?: string | undefined;
    DataVencimento?: Date;
}

export interface UploadCertificadoResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: UploadCertificadoResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UsuarioInfoResponse {
    UsuarioId?: number;
    EmpresaId?: number;
    EmpresaNome?: string | undefined;
    EmpresaLogoUrl?: string | undefined;
    Nome?: string | undefined;
    Sobrenome?: string | undefined;
    Email?: string | undefined;
    CompanhiaId?: string | undefined;
    CompanhiaNome?: string | undefined;
    AlteraCompanhia?: boolean;
    AcessoUsuarios?: boolean;
    AcessoClientes?: boolean;
    AcessoCompanhias?: boolean;
    DataAlteracao?: Date;
    UrlFoto?: string | undefined;
}

export interface UsuarioInsertRequest {
    EmpresaId?: number;
    Nome?: string | undefined;
    Sobrenome?: string | undefined;
    Email?: string | undefined;
    CompanhiaId?: number;
    AlteraCompanhia?: boolean;
    AcessoUsuarios?: boolean;
    AcessoClientes?: boolean;
    AcessoCompanhias?: boolean;
    UsuarioInsercaoId?: number;
    CertificadoDigitalId?: number | undefined;
}

export interface UsuarioLoginRequest {
    Email?: string | undefined;
    Senha?: string | undefined;
    AlterarSenhar?: boolean;
    NovaSenha?: string | undefined;
    NovaSenhaConfirmacao?: string | undefined;
}

export interface UsuarioLoginResponse {
    AccessToken?: string | undefined;
    UsuarioInfo?: UsuarioInfoResponse;
    AlterarSenha?: boolean;
}

export interface UsuarioLoginResponseApiResponse {
    Sucesso?: boolean;
    Dados?: UsuarioLoginResponse;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UsuarioResponseDto {
    UsuarioId?: number;
    Nome?: string | undefined;
    Sobrenome?: string | undefined;
    Email?: string | undefined;
    CompanhiaId?: number;
    CompanhiaNome?: string | undefined;
    AlteraCompanhia?: boolean;
    AcessoUsuarios?: boolean;
    AcessoClientes?: boolean;
    AcessoCompanhias?: boolean;
    DataCriacao?: Date;
    Bloqueado?: boolean;
    CertificadoDigitalId?: number | undefined;
}

export interface UsuarioResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: UsuarioResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UsuarioResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: UsuarioResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UsuarioUpdateRequest {
    UsuarioId?: number;
    Nome?: string | undefined;
    Sobrenome?: string | undefined;
    CompanhiaId?: number;
    AlteraCompanhia?: boolean;
    AcessoUsuarios?: boolean;
    AcessoClientes?: boolean;
    AcessoCompanhias?: boolean;
    Bloqueado?: boolean;
    UsuarioModificadorId?: number;
    CertificadoDigitalId?: number | undefined;
}

export interface VooInsertRequestDto {
    Numero?: string | undefined;
    DataVoo?: Date;
    DataHoraSaidaReal?: Date | undefined;
    DataHoraSaidaPrevista?: Date | undefined;
    AeroportoOrigemCodigo?: string | undefined;
    Trechos?: VooInsertTrechoRequest[] | undefined;
}

export interface VooInsertTrechoRequest {
    AeroportoDestinoCodigo?: string | undefined;
    DataHoraChegadaEstimada?: Date | undefined;
    DataHoraSaidaEstimada?: Date | undefined;
}

export interface VooListaResponseDto {
    VooId?: number;
    Numero?: string | undefined;
    SituacaoVoo?: RecordStatus;
    CiaAereaNome?: string | undefined;
    CertificadoValidade?: Date | undefined;
    Trechos?: VooTrechoResponse[] | undefined;
}

export interface VooListaResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: VooListaResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface VooListarInputDto {
    DataVoo?: Date | undefined;
    DataInicial?: Date | undefined;
    DataFinal?: Date | undefined;
}

export interface VooResponseDto {
    VooId?: number;
    Numero?: string | undefined;
    DataVoo?: Date;
    DataHoraSaidaReal?: Date | undefined;
    DataHoraSaidaPrevista?: Date | undefined;
    DataHoraChegadaEstimada?: Date | undefined;
    StatusId?: number;
    SituacaoRFBId?: number;
    ProtocoloRFB?: string | undefined;
    ErroCodigoRFB?: string | undefined;
    ErroDescricaoRFB?: string | undefined;
    DataProtocoloRFB?: Date | undefined;
    UsuarioCriacao?: string | undefined;
    DataCriacao?: Date;
    AeroportoOrigemCodigo?: string | undefined;
    AeroportoDestinoCodigo?: string | undefined;
    Reenviar?: boolean;
    Trechos?: VooTrechoResponse[] | undefined;
}

export interface VooResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: VooResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface VooResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: VooResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface VooTrechoResponse {
    Id?: number;
    AeroportoDestinoCodigo?: string | undefined;
    DataHoraChegadaEstimada?: Date | undefined;
    DataHoraSaidaEstimada?: Date | undefined;
}

export interface VooTrechoResponseIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: VooTrechoResponse[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface VooUpdateRequestDto {
    VooId?: number;
    Numero?: string | undefined;
    DataVoo?: Date | undefined;
    DataHoraSaidaReal?: Date | undefined;
    DataHoraSaidaPrevista?: Date | undefined;
    AeroportoOrigemCodigo?: string | undefined;
    Trechos?: VooUpdateTrechoRequest[] | undefined;
}

export interface VooUpdateTrechoRequest {
    Id?: number | undefined;
    AeroportoDestinoCodigo?: string | undefined;
    DataHoraChegadaEstimada?: Date | undefined;
    DataHoraSaidaEstimada?: Date | undefined;
}

export interface VooUploadInput {
    VooId?: number;
}

export interface VooUploadResponse {
    VooId?: number;
    Numero?: string | undefined;
    DataVoo?: Date;
    DataHoraSaidaReal?: Date | undefined;
    DataHoraSaidaPrevista?: Date | undefined;
    DataHoraChegadaEstimada?: Date | undefined;
    StatusId?: number;
    SituacaoRFBId?: number;
    ProtocoloRFB?: string | undefined;
    ErroCodigoRFB?: string | undefined;
    ErroDescricaoRFB?: string | undefined;
    DataProtocoloRFB?: Date | undefined;
    UsuarioCriacao?: string | undefined;
    DataCriacao?: Date;
    AeroportoOrigemCodigo?: string | undefined;
    AeroportoDestinoCodigo?: string | undefined;
    Reenviar?: boolean;
    Trechos?: VooTrechoResponse[] | undefined;
    ULDs?: UldMasterNumeroQuery[] | undefined;
}

export interface VooUploadResponseApiResponse {
    Sucesso?: boolean;
    Dados?: VooUploadResponse;
    Notificacoes?: Notificacao[] | undefined;
}

export class SwaggerResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}