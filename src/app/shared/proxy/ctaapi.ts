/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const URL_BASE_URL_API = new InjectionToken<string>('URL_BASE_URL_API');

@Injectable()
export class AccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    autenticar(body: UsuarioLoginRequest | undefined): Observable<SwaggerResponse<UsuarioLoginResponseApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Account/Autenticar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutenticar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutenticar(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UsuarioLoginResponseApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UsuarioLoginResponseApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAutenticar(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioLoginResponseApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UsuarioLoginResponseApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioLoginResponseApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class AgenteDeCargaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param agenteId (optional) 
     * @return Success
     */
    obterAgenteDeCargaPorId(agenteId: number | undefined): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/ObterAgenteDeCargaPorId?";
        if (agenteId === null)
            throw new Error("The parameter 'agenteId' cannot be null.");
        else if (agenteId !== undefined)
            url_ += "agenteId=" + encodeURIComponent("" + agenteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterAgenteDeCargaPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterAgenteDeCargaPorId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processObterAgenteDeCargaPorId(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AgenteDeCargaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarAgentesDeCarga(empresaId: number | undefined): Observable<SwaggerResponse<AgenteDeCargaResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/ListarAgentesDeCarga?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarAgentesDeCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarAgentesDeCarga(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<AgenteDeCargaResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<AgenteDeCargaResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarAgentesDeCarga(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AgenteDeCargaResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirAgenteDeCarga(body: AgenteDeCargaInsertRequest | undefined): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/InserirAgenteDeCarga";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirAgenteDeCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirAgenteDeCarga(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processInserirAgenteDeCarga(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AgenteDeCargaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarAgenteDeCarga(body: AgenteDeCargaUpdateRequest | undefined): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/AtualizarAgenteDeCarga";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarAgenteDeCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarAgenteDeCarga(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarAgenteDeCarga(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AgenteDeCargaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param agenteId (optional) 
     * @return Success
     */
    excluirAgenteDeCarga(agenteId: number | undefined): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/ExcluirAgenteDeCarga?";
        if (agenteId === null)
            throw new Error("The parameter 'agenteId' cannot be null.");
        else if (agenteId !== undefined)
            url_ += "agenteId=" + encodeURIComponent("" + agenteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirAgenteDeCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirAgenteDeCarga(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processExcluirAgenteDeCarga(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AgenteDeCargaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarAgentesDeCargaSimples(empresaId: number | undefined): Observable<SwaggerResponse<AgenteDeCargaListaSimplesResponseIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/AgenteDeCarga/ListarAgentesDeCargaSimples?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarAgentesDeCargaSimples(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarAgentesDeCargaSimples(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<AgenteDeCargaListaSimplesResponseIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<AgenteDeCargaListaSimplesResponseIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarAgentesDeCargaSimples(response: HttpResponseBase): Observable<SwaggerResponse<AgenteDeCargaListaSimplesResponseIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AgenteDeCargaListaSimplesResponseIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgenteDeCargaListaSimplesResponseIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class CertificadoDigitalClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarCertificadosDigitais(empresaId: number | undefined): Observable<SwaggerResponse<CertificadoDigitalResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CertificadoDigital/ListarCertificadosDigitais?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarCertificadosDigitais(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarCertificadosDigitais(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<CertificadoDigitalResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<CertificadoDigitalResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarCertificadosDigitais(response: HttpResponseBase): Observable<SwaggerResponse<CertificadoDigitalResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CertificadoDigitalResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CertificadoDigitalResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class CiaAereaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param ciaId (optional) 
     * @return Success
     */
    obterCiaAereaPorId(ciaId: number | undefined): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/ObterCiaAereaPorId?";
        if (ciaId === null)
            throw new Error("The parameter 'ciaId' cannot be null.");
        else if (ciaId !== undefined)
            url_ += "ciaId=" + encodeURIComponent("" + ciaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterCiaAereaPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterCiaAereaPorId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processObterCiaAereaPorId(response: HttpResponseBase): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CiaAereaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAereaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarCiasAereas(empresaId: number | undefined): Observable<SwaggerResponse<CiaAereaResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/ListarCiasAereas?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarCiasAereas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarCiasAereas(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<CiaAereaResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<CiaAereaResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarCiasAereas(response: HttpResponseBase): Observable<SwaggerResponse<CiaAereaResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CiaAereaResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAereaResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirCiaAerea(body: CiaAereaInsertRequest | undefined): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/InserirCiaAerea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirCiaAerea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirCiaAerea(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processInserirCiaAerea(response: HttpResponseBase): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CiaAereaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAereaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarCiaAerea(body: CiaAereaUpdateRequest | undefined): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/AtualizarCiaAerea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarCiaAerea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarCiaAerea(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarCiaAerea(response: HttpResponseBase): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CiaAereaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAereaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param ciaId (optional) 
     * @return Success
     */
    excluirCiaAerea(ciaId: number | undefined): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/ExcluirCiaAerea?";
        if (ciaId === null)
            throw new Error("The parameter 'ciaId' cannot be null.");
        else if (ciaId !== undefined)
            url_ += "ciaId=" + encodeURIComponent("" + ciaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirCiaAerea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirCiaAerea(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processExcluirCiaAerea(response: HttpResponseBase): Observable<SwaggerResponse<CiaAereaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CiaAereaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAereaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarCiasAereasSimples(empresaId: number | undefined): Observable<SwaggerResponse<CiaAreaListaSimplesResponseIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/CiaAerea/ListarCiasAereasSimples?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarCiasAereasSimples(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarCiasAereasSimples(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<CiaAreaListaSimplesResponseIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<CiaAreaListaSimplesResponseIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarCiasAereasSimples(response: HttpResponseBase): Observable<SwaggerResponse<CiaAreaListaSimplesResponseIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CiaAreaListaSimplesResponseIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CiaAreaListaSimplesResponseIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class HouseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param houseId (optional) 
     * @return Success
     */
    obterHousePorId(houseId: number | undefined): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/ObterHousePorId?";
        if (houseId === null)
            throw new Error("The parameter 'houseId' cannot be null.");
        else if (houseId !== undefined)
            url_ += "houseId=" + encodeURIComponent("" + houseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterHousePorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterHousePorId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<HouseResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<HouseResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processObterHousePorId(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HouseResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarHouses(body: HouseListarRequest | undefined): Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/ListarHouses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarHouses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarHouses(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarHouses(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HouseResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarHousesPorDataCriacao(body: MasterHousePorDataCriacaoRequest | undefined): Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/ListarHousesPorDataCriacao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarHousesPorDataCriacao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarHousesPorDataCriacao(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarHousesPorDataCriacao(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HouseResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirHouse(body: HouseInsertRequestDto | undefined): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/InserirHouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirHouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirHouse(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<HouseResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<HouseResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processInserirHouse(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HouseResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarHouse(body: HouseUpdateRequestDto | undefined): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/AtualizarHouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarHouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarHouse(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<HouseResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<HouseResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarHouse(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HouseResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param houseId (optional) 
     * @return Success
     */
    atualizarReenviarHouse(houseId: number | undefined): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/AtualizarReenviarHouse?";
        if (houseId === null)
            throw new Error("The parameter 'houseId' cannot be null.");
        else if (houseId !== undefined)
            url_ += "houseId=" + encodeURIComponent("" + houseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarReenviarHouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarReenviarHouse(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<HouseResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<HouseResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarReenviarHouse(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HouseResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param houseId (optional) 
     * @return Success
     */
    excluirHouse(houseId: number | undefined): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/House/ExcluirHouse?";
        if (houseId === null)
            throw new Error("The parameter 'houseId' cannot be null.");
        else if (houseId !== undefined)
            url_ += "houseId=" + encodeURIComponent("" + houseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirHouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirHouse(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<HouseResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<HouseResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processExcluirHouse(response: HttpResponseBase): Observable<SwaggerResponse<HouseResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HouseResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<HouseResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class MasterClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param masterId (optional) 
     * @return Success
     */
    obterMasterPorId(masterId: number | undefined): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ObterMasterPorId?";
        if (masterId === null)
            throw new Error("The parameter 'masterId' cannot be null.");
        else if (masterId !== undefined)
            url_ += "masterId=" + encodeURIComponent("" + masterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterMasterPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterMasterPorId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<MasterResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<MasterResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processObterMasterPorId(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarMasters(body: MasterListarRequest | undefined): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ListarMasters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarMasters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarMasters(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarMasters(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarMastersPorDataCriacao(body: MasterHousePorDataCriacaoRequest | undefined): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ListarMastersPorDataCriacao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarMastersPorDataCriacao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarMastersPorDataCriacao(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarMastersPorDataCriacao(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    listarMastersVoo(vooId: number | undefined): Observable<SwaggerResponse<MasterVooResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ListarMastersVoo?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarMastersVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarMastersVoo(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<MasterVooResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<MasterVooResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarMastersVoo(response: HttpResponseBase): Observable<SwaggerResponse<MasterVooResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterVooResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterVooResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    listarMastersListaPorVooId(vooId: number | undefined): Observable<SwaggerResponse<MasterListaResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ListarMastersListaPorVooId?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarMastersListaPorVooId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarMastersListaPorVooId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<MasterListaResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<MasterListaResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarMastersListaPorVooId(response: HttpResponseBase): Observable<SwaggerResponse<MasterListaResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterListaResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterListaResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirMaster(body: MasterInsertRequestDto | undefined): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/InserirMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirMaster(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<MasterResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<MasterResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processInserirMaster(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarMaster(body: MasterUpdateRequestDto | undefined): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/AtualizarMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarMaster(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<MasterResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<MasterResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarMaster(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarParcialTotalMaster(body: MasterUpdateTotalParcialRequestDto | undefined): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/AtualizarParcialTotalMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarParcialTotalMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarParcialTotalMaster(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<MasterResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<MasterResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarParcialTotalMaster(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarReeviarMaster(body: AtualizarMasterReenviarRequest | undefined): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/AtualizarReeviarMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarReeviarMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarReeviarMaster(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarReeviarMaster(response: HttpResponseBase): Observable<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    excluirMaster(body: ExcluirMastersByIdRequest | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Master/ExcluirMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirMaster(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processExcluirMaster(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StringApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class NaturezaCargaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param naturezaCargaId (optional) 
     * @return Success
     */
    obterNaturezaCargaPorId(naturezaCargaId: number | undefined): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/NaturezaCarga/ObterNaturezaCargaPorId?";
        if (naturezaCargaId === null)
            throw new Error("The parameter 'naturezaCargaId' cannot be null.");
        else if (naturezaCargaId !== undefined)
            url_ += "naturezaCargaId=" + encodeURIComponent("" + naturezaCargaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterNaturezaCargaPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterNaturezaCargaPorId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processObterNaturezaCargaPorId(response: HttpResponseBase): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <NaturezaCargaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarNaturezaCarga(empresaId: number | undefined): Observable<SwaggerResponse<NaturezaCargaResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/NaturezaCarga/ListarNaturezaCarga?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarNaturezaCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarNaturezaCarga(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NaturezaCargaResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NaturezaCargaResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarNaturezaCarga(response: HttpResponseBase): Observable<SwaggerResponse<NaturezaCargaResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <NaturezaCargaResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NaturezaCargaResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirNaturezaCarga(body: NaturezaCargaInsertRequestDto | undefined): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/NaturezaCarga/InserirNaturezaCarga";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirNaturezaCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirNaturezaCarga(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processInserirNaturezaCarga(response: HttpResponseBase): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <NaturezaCargaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarNaturezaCarga(body: NaturezaCargaUpdateRequestDto | undefined): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/NaturezaCarga/AtualizarNaturezaCarga";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarNaturezaCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarNaturezaCarga(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarNaturezaCarga(response: HttpResponseBase): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <NaturezaCargaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param naturezaCargaId (optional) 
     * @return Success
     */
    excluirNaturezaCarga(naturezaCargaId: number | undefined): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/NaturezaCarga/ExcluirNaturezaCarga?";
        if (naturezaCargaId === null)
            throw new Error("The parameter 'naturezaCargaId' cannot be null.");
        else if (naturezaCargaId !== undefined)
            url_ += "naturezaCargaId=" + encodeURIComponent("" + naturezaCargaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirNaturezaCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirNaturezaCarga(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processExcluirNaturezaCarga(response: HttpResponseBase): Observable<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <NaturezaCargaResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NaturezaCargaResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class PortoIATAClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param portoIATAId (optional) 
     * @return Success
     */
    obterPortoIATAPorId(portoIATAId: number | undefined): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/PortoIATA/ObterPortoIATAPorId?";
        if (portoIATAId === null)
            throw new Error("The parameter 'portoIATAId' cannot be null.");
        else if (portoIATAId !== undefined)
            url_ += "portoIATAId=" + encodeURIComponent("" + portoIATAId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterPortoIATAPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterPortoIATAPorId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processObterPortoIATAPorId(response: HttpResponseBase): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PortoIATAResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PortoIATAResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarPortosIATA(empresaId: number | undefined): Observable<SwaggerResponse<PortoIATAResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/PortoIATA/ListarPortosIATA?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarPortosIATA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarPortosIATA(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PortoIATAResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PortoIATAResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarPortosIATA(response: HttpResponseBase): Observable<SwaggerResponse<PortoIATAResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PortoIATAResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PortoIATAResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirPortoIATA(body: PortoIATAInsertRequestDto | undefined): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/PortoIATA/InserirPortoIATA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirPortoIATA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirPortoIATA(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processInserirPortoIATA(response: HttpResponseBase): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PortoIATAResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PortoIATAResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarPortoIATA(body: PortoIATAUpdateRequestDto | undefined): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/PortoIATA/AtualizarPortoIATA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarPortoIATA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarPortoIATA(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarPortoIATA(response: HttpResponseBase): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PortoIATAResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PortoIATAResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param portoIATAId (optional) 
     * @return Success
     */
    excluirPortoIATA(portoIATAId: number | undefined): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/PortoIATA/ExcluirPortoIATA?";
        if (portoIATAId === null)
            throw new Error("The parameter 'portoIATAId' cannot be null.");
        else if (portoIATAId !== undefined)
            url_ += "portoIATAId=" + encodeURIComponent("" + portoIATAId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirPortoIATA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirPortoIATA(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processExcluirPortoIATA(response: HttpResponseBase): Observable<SwaggerResponse<PortoIATAResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PortoIATAResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PortoIATAResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class ReceitaFederalClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submeterVooCompleto(body: VooUploadInput | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/ReceitaFederal/SubmeterVooCompleto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmeterVooCompleto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmeterVooCompleto(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processSubmeterVooCompleto(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StringApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verificarProtocoloVoo(body: VooUploadInput | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/ReceitaFederal/VerificarProtocoloVoo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerificarProtocoloVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerificarProtocoloVoo(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processVerificarProtocoloVoo(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StringApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submeterMasterExclusion(body: MasterExclusaoRFBInput | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/ReceitaFederal/SubmeterMasterExclusion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmeterMasterExclusion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmeterMasterExclusion(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processSubmeterMasterExclusion(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StringApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    submeterHouseAgenteDeCarga(body: SubmeterRFBHouseRequest | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/ReceitaFederal/SubmeterHouseAgenteDeCarga";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmeterHouseAgenteDeCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmeterHouseAgenteDeCarga(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processSubmeterHouseAgenteDeCarga(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StringApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class UldClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param uldId (optional) 
     * @return Success
     */
    pegarUldMasterPorId(uldId: number | undefined): Observable<SwaggerResponse<UldMasterResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/PegarUldMasterPorId?";
        if (uldId === null)
            throw new Error("The parameter 'uldId' cannot be null.");
        else if (uldId !== undefined)
            url_ += "uldId=" + encodeURIComponent("" + uldId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPegarUldMasterPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPegarUldMasterPorId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UldMasterResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UldMasterResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processPegarUldMasterPorId(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UldMasterResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param masterId (optional) 
     * @return Success
     */
    listarUldMasterPorMasterId(masterId: number | undefined): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ListarUldMasterPorMasterId?";
        if (masterId === null)
            throw new Error("The parameter 'masterId' cannot be null.");
        else if (masterId !== undefined)
            url_ += "masterId=" + encodeURIComponent("" + masterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarUldMasterPorMasterId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarUldMasterPorMasterId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarUldMasterPorMasterId(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UldMasterResponseDtoListApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterResponseDtoListApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    listarUldMasterPorVooId(vooId: number | undefined): Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ListarUldMasterPorVooId?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarUldMasterPorVooId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarUldMasterPorVooId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarUldMasterPorVooId(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UldMasterNumeroQueryIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterNumeroQueryIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarUldMasterPorLinha(body: ListaUldMasterRequest | undefined): Observable<SwaggerResponse<UldMasterResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ListarUldMasterPorLinha";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarUldMasterPorLinha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarUldMasterPorLinha(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UldMasterResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UldMasterResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarUldMasterPorLinha(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UldMasterResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarMasterUldSumario(body: ListaUldMasterRequest | undefined): Observable<SwaggerResponse<MasterNumeroUldSumarioIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ListarMasterUldSumario";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarMasterUldSumario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarMasterUldSumario(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<MasterNumeroUldSumarioIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<MasterNumeroUldSumarioIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarMasterUldSumario(response: HttpResponseBase): Observable<SwaggerResponse<MasterNumeroUldSumarioIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterNumeroUldSumarioIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<MasterNumeroUldSumarioIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirUldMaster(body: UldMasterInsertRequest[] | null | undefined): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/InserirUldMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirUldMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirUldMaster(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processInserirUldMaster(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UldMasterResponseDtoListApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterResponseDtoListApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarUldMaster(body: UldMasterUpdateRequest[] | null | undefined): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/AtualizarUldMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarUldMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarUldMaster(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarUldMaster(response: HttpResponseBase): Observable<SwaggerResponse<UldMasterResponseDtoListApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UldMasterResponseDtoListApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UldMasterResponseDtoListApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    excluirUldMaster(body: UldMasterDeleteByIdInput | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ExcluirUldMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirUldMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirUldMaster(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processExcluirUldMaster(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StringApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    excluirUld(body: UldMasterDeleteByTagInput | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Uld/ExcluirUld";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirUld(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirUld(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processExcluirUld(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StringApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class UploadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @param usuarioId (optional) 
     * @param senha (optional) 
     * @param empresaId (optional) 
     * @param certificadoDestino (optional) 
     * @param file (optional) 
     * @return Success
     */
    uploadCertificadoDigital(id: number | undefined, usuarioId: number | undefined, senha: string | null | undefined, empresaId: number | undefined, certificadoDestino: FileDestinationMap | undefined, file: FileParameter | null | undefined): Observable<SwaggerResponse<UploadCertificadoResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Upload/UploadCertificadoDigital";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (usuarioId === null || usuarioId === undefined)
            throw new Error("The parameter 'usuarioId' cannot be null.");
        else
            content_.append("UsuarioId", usuarioId.toString());
        if (senha !== null && senha !== undefined)
            content_.append("Senha", senha.toString());
        if (empresaId === null || empresaId === undefined)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else
            content_.append("EmpresaId", empresaId.toString());
        if (certificadoDestino === null || certificadoDestino === undefined)
            throw new Error("The parameter 'certificadoDestino' cannot be null.");
        else
            content_.append("CertificadoDestino", certificadoDestino.toString());
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadCertificadoDigital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadCertificadoDigital(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UploadCertificadoResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UploadCertificadoResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processUploadCertificadoDigital(response: HttpResponseBase): Observable<SwaggerResponse<UploadCertificadoResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UploadCertificadoResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UploadCertificadoResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class UsuarioClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param usuarioId (optional) 
     * @return Success
     */
    obterUsuarioPorId(usuarioId: number | undefined): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/ObterUsuarioPorId?";
        if (usuarioId === null)
            throw new Error("The parameter 'usuarioId' cannot be null.");
        else if (usuarioId !== undefined)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterUsuarioPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterUsuarioPorId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processObterUsuarioPorId(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UsuarioResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param empresaId (optional) 
     * @return Success
     */
    listarUsuarios(empresaId: number | undefined): Observable<SwaggerResponse<UsuarioResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/ListarUsuarios?";
        if (empresaId === null)
            throw new Error("The parameter 'empresaId' cannot be null.");
        else if (empresaId !== undefined)
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarUsuarios(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarUsuarios(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UsuarioResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UsuarioResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarUsuarios(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UsuarioResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirUsuario(body: UsuarioInsertRequest | undefined): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/InserirUsuario";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirUsuario(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processInserirUsuario(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UsuarioResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarUsuario(body: UsuarioUpdateRequest | undefined): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/AtualizarUsuario";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarUsuario(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarUsuario(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UsuarioResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetarUsuario(body: UsuarioUpdateRequest | undefined): Observable<SwaggerResponse<StringApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/ResetarUsuario";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetarUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetarUsuario(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StringApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processResetarUsuario(response: HttpResponseBase): Observable<SwaggerResponse<StringApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StringApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StringApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param usuarioId (optional) 
     * @return Success
     */
    excluirUsuario(usuarioId: number | undefined): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Usuario/ExcluirUsuario?";
        if (usuarioId === null)
            throw new Error("The parameter 'usuarioId' cannot be null.");
        else if (usuarioId !== undefined)
            url_ += "usuarioId=" + encodeURIComponent("" + usuarioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirUsuario(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processExcluirUsuario(response: HttpResponseBase): Observable<SwaggerResponse<UsuarioResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UsuarioResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<UsuarioResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

@Injectable()
export class VooClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(URL_BASE_URL_API) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    obterVooPorId(vooId: number | undefined): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/ObterVooPorId?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterVooPorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterVooPorId(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<VooResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<VooResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processObterVooPorId(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VooResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarVoos(body: VooListarInputDto | undefined): Observable<SwaggerResponse<VooResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/ListarVoos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarVoos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarVoos(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<VooResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<VooResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarVoos(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VooResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listarVoosLista(body: VooListarInputDto | undefined): Observable<SwaggerResponse<VooListaResponseDtoIEnumerableApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/ListarVoosLista";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarVoosLista(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarVoosLista(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<VooListaResponseDtoIEnumerableApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<VooListaResponseDtoIEnumerableApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processListarVoosLista(response: HttpResponseBase): Observable<SwaggerResponse<VooListaResponseDtoIEnumerableApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VooListaResponseDtoIEnumerableApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooListaResponseDtoIEnumerableApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inserirVoo(body: VooInsertRequestDto | undefined): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/InserirVoo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInserirVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInserirVoo(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<VooResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<VooResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processInserirVoo(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VooResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    atualizarVoo(body: VooUpdateRequestDto | undefined): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/AtualizarVoo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarVoo(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<VooResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<VooResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarVoo(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VooResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    atualizarReenviarVoo(vooId: number | undefined): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/AtualizarReenviarVoo?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAtualizarReenviarVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAtualizarReenviarVoo(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<VooResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<VooResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processAtualizarReenviarVoo(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VooResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param vooId (optional) 
     * @return Success
     */
    excluirVoo(vooId: number | undefined): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        let url_ = this.baseUrl + "/api/v1/Voo/ExcluirVoo?";
        if (vooId === null)
            throw new Error("The parameter 'vooId' cannot be null.");
        else if (vooId !== undefined)
            url_ += "vooId=" + encodeURIComponent("" + vooId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcluirVoo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcluirVoo(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<VooResponseDtoApiResponse>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<VooResponseDtoApiResponse>>><any>_observableThrow(response_);
        }));
    }

    protected processExcluirVoo(response: HttpResponseBase): Observable<SwaggerResponse<VooResponseDtoApiResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VooResponseDtoApiResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<VooResponseDtoApiResponse>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface UsuarioLoginRequest {
    Email?: string | undefined;
    Senha?: string | undefined;
    AlterarSenhar?: boolean;
    NovaSenha?: string | undefined;
    NovaSenhaConfirmacao?: string | undefined;
}

export interface UsuarioInfoResponse {
    UsuarioId?: number;
    EmpresaId?: number;
    Nome?: string | undefined;
    Sobrenome?: string | undefined;
    Email?: string | undefined;
    CompanhiaId?: string | undefined;
    CompanhiaNome?: string | undefined;
    AlteraCompanhia?: boolean;
    AcessoUsuarios?: boolean;
    AcessoClientes?: boolean;
    AcessoCompanhias?: boolean;
    DataAlteracao?: Date;
    UrlFoto?: string | undefined;
}

export interface UsuarioLoginResponse {
    AccessToken?: string | undefined;
    UsuarioInfo?: UsuarioInfoResponse;
    AlterarSenha?: boolean;
}

export interface Notificacao {
    Codigo?: string | undefined;
    Mensagem?: string | undefined;
}

export interface UsuarioLoginResponseApiResponse {
    Sucesso?: boolean;
    Dados?: UsuarioLoginResponse;
    Notificacoes?: Notificacao[] | undefined;
}

export interface AgenteDeCargaResponseDto {
    AgenteDeCargaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    Numero?: string | undefined;
    ArquivoCertificado?: string | undefined;
    DataExpiracaoCertificado?: Date | undefined;
}

export interface AgenteDeCargaResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: AgenteDeCargaResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface AgenteDeCargaResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: AgenteDeCargaResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface AgenteDeCargaInsertRequest {
    EmpresaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    UsuarioId?: number;
    Numero?: string | undefined;
}

export interface AgenteDeCargaUpdateRequest {
    AgenteDeCargaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    UsuarioId?: number;
    Numero?: string | undefined;
}

export interface AgenteDeCargaListaSimplesResponse {
    AgenteDeCargaId?: number;
    Nome?: string | undefined;
}

export interface AgenteDeCargaListaSimplesResponseIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: AgenteDeCargaListaSimplesResponse[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface CertificadoDigitalResponseDto {
    UsuarioCriacaoId?: number;
    UsuarioCriacao?: string | undefined;
    DataCriacao?: Date;
    UsuarioModificadorId?: number | undefined;
    UsuarioModificacao?: string | undefined;
    DataModificacao?: Date | undefined;
    Id?: number;
    Arquivo?: string | undefined;
    DataVencimento?: Date;
    NomeDono?: string | undefined;
    SerialNumber?: string | undefined;
}

export interface CertificadoDigitalResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: CertificadoDigitalResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface CiaAereaResponseDto {
    CiaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    Numero?: string | undefined;
    ArquivoCertificado?: string | undefined;
    DataExpiracaoCertificado?: Date | undefined;
}

export interface CiaAereaResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: CiaAereaResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface CiaAereaResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: CiaAereaResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface CiaAereaInsertRequest {
    EmpresaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    UsuarioId?: number;
    Numero?: string | undefined;
}

export interface CiaAereaUpdateRequest {
    CiaId?: number;
    Nome?: string | undefined;
    CNPJ?: string | undefined;
    Endereco1?: string | undefined;
    Endereco2?: string | undefined;
    Cidade?: string | undefined;
    Estado?: string | undefined;
    Pais?: string | undefined;
    UsuarioId?: number;
    Numero?: string | undefined;
}

export interface CiaAreaListaSimplesResponse {
    CiaId?: number;
    Nome?: string | undefined;
}

export interface CiaAreaListaSimplesResponseIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: CiaAreaListaSimplesResponse[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface HouseResponseDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalVolumes?: number;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: number;
    RUC?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigem?: string | undefined;
    AeroportoDestino?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    MasterNumeroXML?: string | undefined;
    NCMLista?: string[] | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    AgenteDeCargaNumero?: string | undefined;
    HouseId?: number;
    StatusId?: number;
    SituacaoRFB?: number;
    DataProcessamento?: Date;
    Reenviar?: boolean;
}

export interface HouseResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: HouseResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface HouseListarRequest {
    DataProcessamento?: Date | undefined;
    AgenteDeCargaId?: number | undefined;
    DataCriacaoInicialUnica?: Date | undefined;
    DataCriacaoFinal?: Date | undefined;
    NumeroMaster?: string | undefined;
    Numero?: string | undefined;
    NomeLike?: string | undefined;
    StatusReceita?: number | undefined;
    DataEnvioReceita?: Date | undefined;
}

export interface HouseResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: HouseResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface MasterHousePorDataCriacaoRequest {
    CiaId?: number;
    DataCriacao?: Date;
}

export interface HouseInsertRequestDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalVolumes?: number;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: number;
    RUC?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigem?: string | undefined;
    AeroportoDestino?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    MasterNumeroXML?: string | undefined;
    NCMLista?: string[] | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    AgenteDeCargaNumero?: string | undefined;
    EmpresaId?: number;
    UsuarioInsercaoId?: number;
    DataProcessamento?: Date;
}

export interface HouseUpdateRequestDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalVolumes?: number;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: number;
    RUC?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigem?: string | undefined;
    AeroportoDestino?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    MasterNumeroXML?: string | undefined;
    NCMLista?: string[] | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    AgenteDeCargaNumero?: string | undefined;
    HouseId?: number;
    UsuarioAlteradorId?: number;
}

export interface MasterErroDto {
    Erro?: string | undefined;
}

export enum RecordStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export interface MasterResponseDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalPecas?: number;
    ValorFOB?: number;
    ValorFOBUN?: string | undefined;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    IndicadorNaoDesunitizacao?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: number;
    RUC?: string | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    RemetenteSubdivisao?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigemCodigo?: string | undefined;
    AeroportoDestinoCodigo?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    NumeroVooXML?: string | undefined;
    NCMLista?: string[] | undefined;
    ConsolidadoDireto?: string | undefined;
    TotalParcial?: string | undefined;
    NaturezaCarga?: string | undefined;
    MasterId?: number;
    StatusId?: number;
    SituacaoRFB?: number;
    ProtocoloRFB?: string | undefined;
    CodigoErroRFB?: string | undefined;
    DescricoErroRFB?: string | undefined;
    DataProtocoloRFB?: Date | undefined;
    Erros?: MasterErroDto[] | undefined;
    Reenviar?: boolean;
    StatusVoo?: RecordStatus;
    VooReenviar?: boolean;
    UsuarioCriacao?: string | undefined;
    DataCriacao?: Date;
}

export interface MasterResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: MasterResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export enum RFStatusEnvioType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export interface MasterListarRequest {
    CiaAereaId?: number | undefined;
    VooId?: number | undefined;
    DataCriacaoInicialUnica?: Date | undefined;
    DataCriacaoFinal?: Date | undefined;
    Numero?: string | undefined;
    NomeLike?: string | undefined;
    StatusReceita?: RFStatusEnvioType;
    DataEnvioReceita?: Date | undefined;
    EmpresaId?: number | undefined;
}

export interface MasterResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: MasterResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface MasterVooResponseDto {
    Numero?: string | undefined;
    CodigoTipo?: string | undefined;
    Peso?: number;
    PesoUnidade?: string | undefined;
    TotalVolumes?: number;
    Descricao?: string | undefined;
    PortoOrigemId?: number;
    PortoDestinoId?: number;
}

export interface MasterVooResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: MasterVooResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface MasterListaResponseDto {
    MasterId?: number;
    Numero?: string | undefined;
}

export interface MasterListaResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: MasterListaResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface MasterInsertRequestDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalPecas?: number;
    ValorFOB?: number;
    ValorFOBUN?: string | undefined;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    IndicadorNaoDesunitizacao?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: number;
    RUC?: string | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    RemetenteSubdivisao?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigemCodigo?: string | undefined;
    AeroportoDestinoCodigo?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    NumeroVooXML?: string | undefined;
    NCMLista?: string[] | undefined;
    ConsolidadoDireto?: string | undefined;
    TotalParcial?: string | undefined;
    NaturezaCarga?: string | undefined;
    EmpresaId?: number;
    VooId?: number;
    UsuarioInsercaoId?: number;
    CiaAereaId?: number;
    DataVoo?: Date;
}

export interface MasterUpdateRequestDto {
    Numero?: string | undefined;
    PesoTotalBruto?: number;
    PesoTotalBrutoUN?: string | undefined;
    TotalPecas?: number;
    ValorFOB?: number;
    ValorFOBUN?: string | undefined;
    ValorFretePP?: number;
    ValorFretePPUN?: string | undefined;
    ValorFreteFC?: number;
    ValorFreteFCUN?: string | undefined;
    IndicadorMadeiraMacica?: boolean;
    IndicadorNaoDesunitizacao?: boolean;
    DescricaoMercadoria?: string | undefined;
    CodigoRecintoAduaneiro?: number;
    RUC?: string | undefined;
    RemetenteNome?: string | undefined;
    RemetenteEndereco?: string | undefined;
    RemetentePostal?: string | undefined;
    RemetenteCidade?: string | undefined;
    RemetentePaisCodigo?: string | undefined;
    RemetenteSubdivisao?: string | undefined;
    ConsignatarioNome?: string | undefined;
    ConsignatarioEndereco?: string | undefined;
    ConsignatarioPostal?: string | undefined;
    ConsignatarioCidade?: string | undefined;
    ConsignatarioPaisCodigo?: string | undefined;
    ConsignatarioSubdivisao?: string | undefined;
    ConsignatarioCNPJ?: string | undefined;
    AeroportoOrigemCodigo?: string | undefined;
    AeroportoDestinoCodigo?: string | undefined;
    DataEmissaoXML?: Date | undefined;
    NumeroVooXML?: string | undefined;
    NCMLista?: string[] | undefined;
    ConsolidadoDireto?: string | undefined;
    TotalParcial?: string | undefined;
    NaturezaCarga?: string | undefined;
    MasterId?: number;
    UsuarioAlteradorId?: number;
    DataVoo?: Date;
}

export interface MasterUpdateTotalParcialRequestDto {
    MasterId?: number;
    UsuarioAlteradorId?: number;
    TotalParcial?: string | undefined;
}

export interface AtualizarMasterReenviarRequest {
    MasterIds?: number[] | undefined;
}

export interface ExcluirMastersByIdRequest {
    MasterIds?: number[] | undefined;
}

export interface StringApiResponse {
    Sucesso?: boolean;
    Dados?: string | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface NaturezaCargaResponseDto {
    NaturezaCargaId?: number;
    Codigo?: string | undefined;
    Descricao?: string | undefined;
}

export interface NaturezaCargaResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: NaturezaCargaResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface NaturezaCargaResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: NaturezaCargaResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface NaturezaCargaInsertRequestDto {
    Codigo?: string | undefined;
    Descricao?: string | undefined;
    UsuarioInsercaoId?: number;
    EmpresaId?: number;
}

export interface NaturezaCargaUpdateRequestDto {
    NaturezaCargaId?: number;
    Descricao?: string | undefined;
    UsuarioModificadorId?: number;
}

export interface PortoIATAResponseDto {
    PortoId?: number;
    Codigo?: string | undefined;
    Nome?: string | undefined;
}

export interface PortoIATAResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: PortoIATAResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface PortoIATAResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: PortoIATAResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface PortoIATAInsertRequestDto {
    Codigo?: string | undefined;
    Nome?: string | undefined;
    UsuarioInsercaoId?: number;
    EmpresaId?: number;
}

export interface PortoIATAUpdateRequestDto {
    PortoIATAId?: number;
    Nome?: string | undefined;
    UsuarioModificadorId?: number;
}

export interface VooUploadInput {
    UsuarioId?: number;
    VooId?: number;
}

export interface MasterExclusaoRFBInput {
    UsuarioId?: number;
    MasterId?: number;
}

export interface SubmeterRFBHouseRequest {
    DataProcessamento?: Date;
    AgenteDeCargaId?: number;
}

export interface UldMasterResponseDto {
    MasterNumero?: string | undefined;
    UldId?: string | undefined;
    UldCaracteristicaCodigo?: string | undefined;
    UldIdPrimario?: string | undefined;
    QuantidadePecas?: number;
    Peso?: number;
    Id?: number;
    MasterId?: number;
    UsuarioCriacao?: string | undefined;
    DataCricao?: Date | undefined;
}

export interface UldMasterResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: UldMasterResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UldMasterResponseDtoListApiResponse {
    Sucesso?: boolean;
    Dados?: UldMasterResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UldMasterNumeroQueryChildren {
    MasterId?: number;
    MasterNumero?: string | undefined;
    UldId?: string | undefined;
    UldCaracteristicaCodigo?: string | undefined;
    UldIdPrimario?: string | undefined;
    QuantidadePecas?: number | undefined;
    Peso?: number | undefined;
    PesoUnidade?: string | undefined;
    Id?: number;
    UsuarioCriacao?: string | undefined;
    DataCricao?: Date;
}

export interface UldMasterNumeroQuery {
    ULDCaracteristicaCodigo?: string | undefined;
    ULDId?: string | undefined;
    ULDIdPrimario?: string | undefined;
    readonly ULDLinha?: string | undefined;
    ULDs?: UldMasterNumeroQueryChildren[] | undefined;
}

export interface UldMasterNumeroQueryIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: UldMasterNumeroQuery[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface ListaUldMasterRequest {
    vooId?: number;
    uldLinha?: string | undefined;
}

export interface UldMasterResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: UldMasterResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface MasterNumeroUldSumarioChildren {
    UldNumero?: string | undefined;
    QuantidadePecas?: number;
    Peso?: number;
    PesoUnidade?: string | undefined;
    TotalParcial?: string | undefined;
    MesmoVoo?: boolean;
    VooNumero?: string | undefined;
    DataHoraChegadaEstimada?: Date | undefined;
    DataHoraChegadaReal?: Date | undefined;
}

export interface MasterNumeroUldSumario {
    MasterNumero?: string | undefined;
    MasterPecas?: number | undefined;
    MasterPeso?: number | undefined;
    MasterPesoUnidade?: string | undefined;
    Ulds?: MasterNumeroUldSumarioChildren[] | undefined;
}

export interface MasterNumeroUldSumarioIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: MasterNumeroUldSumario[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UldMasterInsertRequest {
    MasterNumero?: string | undefined;
    UldId?: string | undefined;
    UldCaracteristicaCodigo?: string | undefined;
    UldIdPrimario?: string | undefined;
    QuantidadePecas?: number;
    Peso?: number;
    UsuarioId?: number;
    VooId?: number;
    EmpresaId?: number;
}

export interface UldMasterUpdateRequest {
    MasterNumero?: string | undefined;
    UldId?: string | undefined;
    UldCaracteristicaCodigo?: string | undefined;
    UldIdPrimario?: string | undefined;
    QuantidadePecas?: number;
    Peso?: number;
    Id?: number;
    UsuarioId?: number;
    VooId?: number;
}

export interface UldMasterDeleteByIdInput {
    VooId?: number;
    ListaIds?: number[] | undefined;
}

export interface UldMasterDeleteByTagInput {
    VooId?: number;
    ULDId?: string | undefined;
    ULDCaracteristicaCodigo?: string | undefined;
    ULDIdPrimario?: string | undefined;
}

export enum FileDestinationMap {
    _0 = 0,
    _1 = 1,
}

export interface UploadCertificadoResponseDto {
    NomeArquivo?: string | undefined;
    DataVencimento?: Date;
}

export interface UploadCertificadoResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: UploadCertificadoResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UsuarioResponseDto {
    UsuarioId?: number;
    Nome?: string | undefined;
    Sobrenome?: string | undefined;
    Email?: string | undefined;
    CompanhiaId?: number;
    CompanhiaNome?: string | undefined;
    AlteraCompanhia?: boolean;
    AcessoUsuarios?: boolean;
    AcessoClientes?: boolean;
    AcessoCompanhias?: boolean;
    DataCriacao?: Date;
    Bloqueado?: boolean;
    CertificadoDigitalId?: number | undefined;
}

export interface UsuarioResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: UsuarioResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UsuarioResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: UsuarioResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface UsuarioInsertRequest {
    EmpresaId?: number;
    Nome?: string | undefined;
    Sobrenome?: string | undefined;
    Email?: string | undefined;
    CompanhiaId?: number;
    AlteraCompanhia?: boolean;
    AcessoUsuarios?: boolean;
    AcessoClientes?: boolean;
    AcessoCompanhias?: boolean;
    UsuarioInsercaoId?: number;
    CertificadoDigitalId?: number | undefined;
}

export interface UsuarioUpdateRequest {
    UsuarioId?: number;
    Nome?: string | undefined;
    Sobrenome?: string | undefined;
    CompanhiaId?: number;
    AlteraCompanhia?: boolean;
    AcessoUsuarios?: boolean;
    AcessoClientes?: boolean;
    AcessoCompanhias?: boolean;
    Bloqueado?: boolean;
    UsuarioModificadorId?: number;
    CertificadoDigitalId?: number | undefined;
}

export interface VooResponseDto {
    VooId?: number;
    Numero?: string | undefined;
    DataVoo?: Date;
    DataHoraSaidaEstimada?: Date | undefined;
    DataHoraSaidaReal?: Date | undefined;
    DataHoraChegadaEstimada?: Date | undefined;
    DataHoraChegadaReal?: Date | undefined;
    PesoBruto?: number | undefined;
    PesoBrutoUnidade?: string | undefined;
    Volume?: number | undefined;
    VolumeUnidade?: string | undefined;
    TotalPacotes?: number | undefined;
    TotalPecas?: number | undefined;
    StatusId?: number;
    SituacaoRFBId?: number;
    ProtocoloRFB?: string | undefined;
    ErroCodigoRFB?: string | undefined;
    ErroDescricaoRFB?: string | undefined;
    DataProtocoloRFB?: Date | undefined;
    UsuarioCriacao?: string | undefined;
    DataCriacao?: Date;
    AeroportoOrigemCodigo?: string | undefined;
    AeroportoDestinoCodigo?: string | undefined;
    Reenviar?: boolean;
}

export interface VooResponseDtoApiResponse {
    Sucesso?: boolean;
    Dados?: VooResponseDto;
    Notificacoes?: Notificacao[] | undefined;
}

export interface VooListarInputDto {
    CompanhiaId?: number | undefined;
    DataVoo?: Date | undefined;
    DataInicial?: Date | undefined;
    DataFinal?: Date | undefined;
}

export interface VooResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: VooResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface VooListaResponseDto {
    VooId?: number;
    Numero?: string | undefined;
    SituacaoVoo?: RecordStatus;
}

export interface VooListaResponseDtoIEnumerableApiResponse {
    Sucesso?: boolean;
    Dados?: VooListaResponseDto[] | undefined;
    Notificacoes?: Notificacao[] | undefined;
}

export interface VooInsertRequestDto {
    EmpresaId?: number;
    Numero?: string | undefined;
    DataVoo?: Date;
    DataHoraSaidaEstimada?: Date | undefined;
    DataHoraSaidaReal?: Date | undefined;
    DataHoraChegadaEstimada?: Date | undefined;
    DataHoraChegadaReal?: Date | undefined;
    PortoOrigemId?: number;
    PortoDestinoId?: number;
    PesoBruto?: number | undefined;
    PesoBrutoUnidade?: string | undefined;
    Volume?: number | undefined;
    VolumeUnidade?: string | undefined;
    TotalPacotes?: number | undefined;
    TotalPecas?: number | undefined;
    UsuarioInsercaoId?: number;
    AeroportoOrigemCodigo?: string | undefined;
    AeroportoDestinoCodigo?: string | undefined;
}

export interface VooUpdateRequestDto {
    VooId?: number;
    DataVoo?: Date;
    DataHoraSaidaEstimada?: Date | undefined;
    DataHoraSaidaReal?: Date | undefined;
    DataHoraChegadaEstimada?: Date | undefined;
    DataHoraChegadaReal?: Date | undefined;
    UsuarioModificadorId?: number;
    AeroportoOrigemCodigo?: string | undefined;
    AeroportoDestinoCodigo?: string | undefined;
}

export class SwaggerResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}